2. âœ… Uveri se da SECRET_KEY u .env fajlu i settings.SECRET_KEY svuda odgovara
env
Copy
Edit
# .env
SECRET_KEY=tajna_kljuc_za_aplikaciju_123

3. âœ… Koristi verify_token() samo iz jednog izvora
Recimo iz core/security.py ili napravi verify_token unutar auth/utils.py,
 ali koristi iskljuÄivo settings.SECRET_KEY iz config.py.



ğŸ“ Gde se SECRET_KEY Äuva? O njemu.
âœ… U .env fajlu:

env
Copy
Edit
SECRET_KEY=tajna_kljuc_za_aplikaciju_123
To je privatni fajl koji ne ide na GitHub â€” najÄeÅ¡Ä‡e se doda u .gitignore. U razvojnoj fazi moÅ¾e da bude jednostavan string, ali u produkciji:

âœ… treba da bude dugaÄak i nasumiÄan.

ğŸ§ª Kako se uÄitava iz .env u kod?
U config.py koristiÅ¡:

python
Copy
Edit
import os
from dotenv import load_dotenv

load_dotenv()  # uÄitava .env varijable u os.environ

class Settings:
    SECRET_KEY: str = os.getenv("SECRET_KEY")
Zatim se koristi ovako:

python
Copy
Edit
from app.config import settings

jwt.encode(data, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
ğŸ§­ VaÅ¾no pravilo: SECRET_KEY mora biti isti:
prilikom kreiranja tokena

prilikom verifikacije tokena

Ako koristiÅ¡ viÅ¡e fajlova (utils.py, core/security.py...) â€” svi moraju koristiti isti settings.SECRET_KEY.

âœ… PreporuÄena vrednost SECRET_KEY u produkciji
Umesto jednostavne reÄi, koristi neÅ¡to poput:

env
Copy
Edit
SECRET_KEY=Jf93lskfEod!3$kdlwq892jsnfA98djwljf0934JSF#@$
MoÅ¾eÅ¡ generisati pomoÄ‡u Python-a:

python
Copy
Edit
import secrets
print(secrets.token_urlsafe(32))